
#  1 概述
在数据模型中进行表/查询关联时，支持对某个数据连接的多个表进行关联，也支持对多个数据连接中的表进行关联。
前置条件
1、数据模型支持自动检测关系，也支持手动创建关系、手动检测关系。
2、数据模型默认开启 **自动检测关系 ,** 如没有开启**：** 需要在运维设置/ 常用功能 / 系统选项/高级设置 设置 OLAP_QUERY_AUTO_ADD_CHECK_LINK=true，在加载表或者查询时才会自动检测关系。
3、如开启了自动检测关系：假设自动检测没检测出来，用户手动设置关系不正确时，会提示关系无效，但目前未强制更正；检测关系的原理就是利用建立关系的字段在表中是否重复，会真实查数据库，部分数据库慢可关闭此检测。
4、暂不支持 **多对多** 。
5、，仅在数据模型是直连模式生效，抽取模式不生效。
6、在V11 版本去掉了 一对一(内连接)、一对一(外连接)，只有 如果是旧资源升级：
  * 一对一(外连接): 升级上来变成了 ，并且不开启 
  * 一对一(内连接): 升级上来变成了，并且开启 


7、产品目前支持设置筛选方向：多对一、一对多默认单向筛选；一对一默认就是双向筛选，详情可查看：双向筛选介绍。
8、基于指标模型生成的数据模型无法设置查询/表关系，详细可查看：指标模型V1.0。
9、你可能会需要查看 界面介绍、设置与修改查询。
# 2 关系
自动识别关系字段原则：相同别名+相同数据类型的字段，会自动关联。
## 2.1 关系用途
1、数据模型设置的关系会应用于模型表列的筛选器传播到其他表或查询， 只要有关系路径可循，筛选器就会进行传播，这可能涉及传播到多个表/查询，
关系路径是确定性的，这意味着筛选器始终以相同的方式传播，不会随机变化。 
2、在下图示例中，模型由四个表组成："Category**"** 、"Product**"** 、"Year**"** Sales**";** Category"Product“Year“Sales” 表， 所有关系均为 **一对多.**
3、关系属性：
  * 模型关系可将一个表/查询中的一列关联到另一个表/查询中的一列。
  * 无法将同一表中的一列关联到另一列。
  * 无法使用数据模型创建父子关系。


4、关系支持：手动创建关系、加载期间自动检测、以及手动检测。
## 2.2 手动创建关系
数据模型支持手动创建关系。
以产品自带的 “产品表”、“订单表”、“产品类别表”等创建订单模型为示例进行说明。
为了更好的说明，先在运维设置/系统选项/高级设置中关闭自动检测表关系的设置项: OLAP_QUERY_AUTO_ADD_CHECK_LINK=false 或者把模型的 自动检测表关系 禁用。
具体操作步骤如下：
1、创建数据模型，并加入 “产品表”、“订单表”、“产品类别表“等表。
2、设置 ”订单表“与”订单明细表“的关系,选中”订单表“ 再右键菜单 **新建关系** 或者通过 **连线** 到另外一个表/查询**，** 会出现 编辑关系对话框。
关系 | 
  * 需要选择原表(左表)的关联字段，再选择目标表(右表)对应的关联字段； 如果原表设置的字段是字符串，那么目标表的也只能选择字符串的字段与之关联。
  * 关系是必填项，一定要设置至少一个关系；点击 支持新建多个关系；假设设置了多个关系，生成的SQL语句是and关系。
  * 关系支持设置 比如想要关系字段需要使用contact、replace等函数进行拼接、替换等，需要使用自定义计算列。

  
---|---  
条件 | 默认 等于，支持等于、不等于、大于等于、小于、小于等于；如果是抽取模式，并且缓存库是ClickHouse，则不支持 等于、不等于、大于等于、小于、小于等于 条件(ClickHouse库本身不支持)**。**  
  * 定义: 连接基数：属于连接的自然属性(与数据分析领域无关），一般，在有主键、外键的表建立关系时:
    1. 一对多、多对一 关系：字段通过外键关联到目标表的主键字段、或唯一索引字段。
    2. 一对一：通过主键字段(或唯一索引字段)关联到另外一个表或查询的主键(或唯一索引字段)。
    3. 当数据库缺乏主键/唯一索引信息标识时，需要用户手动创建关系。
  * 如果设置好了关系，但是不知道基数应该选择什么，可以点击旁边的，检测基数。

  
假设引用关系完整性 | 该设置项仅对 直连 模式生效。 详情可查看本篇章节 **假设引用关系完整性 。**  
方式1：
方式2：
3、根据步骤2设置好各个表、查询的关系，最终效果如下,构建了一个 星型模型：
如果发现关系或者基数设置的不对可以对其进行 **删除** 或 **编辑** ：选中连线，再右键菜单删除/编辑，或者选中连线，按delete键。
## 2.3 在加载期间自动检测
  * 开启**自动检测关系：** 需要在**运维设置/ 系统设置 / 高级选项** 设置 OLAP_QUERY_AUTO_ADD_CHECK_LINK=true，或者 数据模型的 **设置/自动检测表关系** 选项选择 “检测”， 在加载表或者模型时才会自动检测关系。
  * 不管是直连还是抽取模式，如果数据模型同时加载两个或多个表/查询时，Smartbi将尝试按照字段数据类型一致且字段别名一致的原则，为你查找并创建关系， “关系”、 “基数” 会根据规则自动创建、选择；如果无法以高置信度确定存在的匹配项，则不会创建关系，但是仍可使用 **新建关系** 对话框来手动创建或者编辑关系。
  * 如果 ”自动检测表关系“是禁用状态，则该模型加载表或查询时，不会自动检测关系，需要手工创建或者使用工具栏的”自动检测“创建关系。


## 2.4 使用"自动检测"创建关系
当系统没有开启自动识别字段关系时，可以点击 **检测关系** 检测各个表/查询之间的关联关系。规则与第2章 **在加载期间自动检测** 一致。
# 3 基数
基数检测原理
1、逐个判断查询相同别名的字段列，是1还是多;当count()的数量和count(distinct(XXXX))的数据不一致，说明该列是多，否则为1。
2、例如orders 与orderDetail 表，关联字段是OrderID，当orders 的count(*)与count(distinct (OrderID))，是一致的，则认为是“一”的一方；当orderDetail的count(*)与count(distinct (OrderID))不是一致时，则认为是“多”的一方。
3、注意：这个检测方法会做一次count，所以数据库执行count慢时，会出现检测性能问题；自动构建表关系就是依赖基数检测结果，如果数据量很大时，建议关闭自动检测基数。
取数逻辑整体概述
1、子图(也可以理解为扩展表)，也可以理解为数据模型中的每个表都可构建一个子图，A表的子图是以A表为中心，根据筛选方向即箭头指向它的，代表能筛选它(比如B-→A，即B可以筛选A)都会把它纳入子图中。
2、每个子图，我们可以理解为以"多" 方 left join "一"方构建子图查询，如果在直连模式下勾选了“假设引用完整性”，也就是”多“方有的记录”一“方一定存在，并且”一“方有的记录，多方也一定存在，子图会用 inner join 构建查询，部分数据库inner join会更快。
3、注意：我们的模型是动态建模，不是基于肥模型建模，根据勾选的字段进行建模的。
用户查询时，是根据用户所选维度、度量、条件，从数据模型中，动态查找相关表及其子图，基于命中后的子图再查数；查询性能，一般和命中的子图本身的查询性能有关，和整个数据模型关系不大或者说是固定消耗（除非模型超大，模型定义的解析消耗较大时间）。
## 3.1 多对一/一对多 
1、“一对多”和“多对一”基数选项基本相同，并且它们也是最常见的基数类型：
  * 缩写：*:1 或 1:*
  * 表/查询的顺序确定是多对一还是一对多（类似于左右联接）。


2、在数据模型中，”订单表“和”订单明细表“基数关系如果是 一**对多** ，代表”订单表“中用于和”订单明细表“建立关系的字段OrderID，在”订单表“是唯一的； ”订单表“中用于建立与”订单明细表“关系的字段值，在”订单明细表“会有多条记录匹配。
  * 如果”订单明细表“在左边，”订单表“在右边，我们需要选择”多对一“的关系；如果“订单表”在左边，“订单明细表”在右边，我们需要选择”一对多“的关系


3、站在业务角度，数据模型中的基数关系（一对一、一对多/多对一），**描述的是真实业务数据之间的联系，能反映真实世界对应业务实体之间的关联关系** ，如一个顾客可以有多笔订单，一个订单可能购买多个产品，一个订单也可能分拆多个快递单等等，对应到数据模型就是：
## 3.2 一对一
1、由于示例使用了**业务表** 进行分析，在复现示例时，可以把数据先导入到模型中，详细请参考**：**导入文件数据**。**
2、示例下载数据：车牌与车俩.xls。 
示例：每辆车都有自己的车牌，车牌是特定于一辆汽车的，汽车与车牌的关系是 **一对一** 的，如下图所示：
具体操作步骤如下：
1、把数据导入到模型中，并且设置好关系、基数:
2、保存模型并去建仪表盘，拖入”车牌“、"汽车识别号", 效果如下图：请注意，即使汽车未注册或车牌号尚未分配给汽车，也同样会查询出来：
# 4 假设引用关系完整性
设置“假设引用完整性”，使数据源上的查询使用 INNER JOIN 语句而不是 OUTER JOIN 语句，从而提高查询效率。
## 4.1 使用假设引用关系完整性的前提条件
仅在连接到使用 的数据时才可用。 若要使“假设引用完整性”正常工作，必须满足以下要求：
  * 关系中 左表/查询 列中的数据始终不能为  _Null_ 或  _空白。_
  * 左表/查询 列中的每个值在 右表/查询 列中都有对应的值。


在这种情况下，左表/查询 列是一对多关系中的“多”，或是一对一关系中第一个表中的列。
## 4.2 设置假设引用完整性
一个表中的值保证另一个表中具有匹配项。换句话说，一个表中不能有另一个表中没有相应记录的记录。
1、勾选该设置项: 取数的SQL 是inner join; 没有勾选: A left join B，B left join A，两个再加起来,是full join的效果。
2、如果在抽取模式勾选了该选项，依然是不生效。
3、如果错误地设置了假设引用完整性，会发生什么？如果在数据中有引用完整性问题时设置“假设引用完整性”，该设置不会导致错误。 但是，可能会导致数据不一致。
## 4.3 使用假设引用完整性的示例
1、创建数据模型并把产品自带的northwind数据库的“产品表(product)”、“订单明细表(OrderDetail )”等加入到模型中。
2、下图显示了 OrderDetail 表和 Products 表，引用完整性存在于 OrderDetail [ProductID] 和 Products[ProductID] 之间。 OrderDetail 表中的**ProductID** _Null_**Products**
3、如下图所示，请注意 Orders[DepotID] 和 Depots[DepotID] 之间不存在引用完整性，因为某些 Orders 的 DepotID 为 Null 。 在这种情况下， 不应设置“**假设引用完整性** ”。
4、如下图所示，请注意 Orders[CustomerID] 和 Customers[CustomerID ] 之间不存在引用完整性，Orders[CustomerID ]包含一些值，这些值不存在于 Customers 表中， 在这种情况下，不应设置 假设引用完整性。
# 5 关系布局
使用数据模型的布局，可以创建仅包含模型中部分表或查询的关系图，可以帮助你提供你想要使用的表的更清晰的视图，并让你能够更为轻松地使用复杂数据模型。
## 5.1 创建单独的关系视图
具体操作如下：
1、以产品自带的northwind数据库的“产品表”、“订单表”等构建“订单模型”。
2、然后在创建单独的关系视图，也可以叫做布局
  * 首先选中 关系视图 **所有表** 右键菜单 **新增布局，** 布局名称默认布局1，布局2，布局3，......。 
  * 再到右侧维度区域 选中“产品表”，然后 右键菜单 **添加相关表 ，** 会把“产品表”相关联的所有表添加到布局中； 
  * 如果发现在布局中添加错了表或查询也可以使用右键菜单的 **从布局中删除** 菜单将其删除。
  * 构建好布局之后，可以在布局上修改各个表/查询的关系，会直接更新到 **所有表** 中。
  * 构建好布局之后，可通过选中布局名称，然后 右键菜单 对应其重命名、或者删除操作，也可以新增更多的布局。
  * 布局里面的表或查询的右键菜单基本与 所有表中右键菜单是一致的，详情可查看：设置及修改查询。
  * 布局支持直接添加各个查询，布局中添加了，在 所有表中也会添加。

  
