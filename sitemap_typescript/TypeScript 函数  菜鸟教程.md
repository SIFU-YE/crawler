# 菜鸟教程 -- 学的不仅是技术，更是梦想！
TypeScript 教程
TypeScript 教程  TypeScript 安装  TypeScript 特性 TypeScript 基础语法  TypeScript 基本结构 TypeScript 基础类型  TypeScript 变量声明  TypeScript 运算符  TypeScript 条件语句  TypeScript 循环  TypeScript Number  TypeScript String  TypeScript Array(数组)  TypeScript Map 对象 TypeScript 元组  TypeScript 联合类型  TypeScript 接口  TypeScript 类  TypeScript 对象  TypeScript 泛型 TypeScript 命名空间  TypeScript 模块  TypeScript 声明文件  TypeScript 测验 
# TypeScript 函数 
函数是一组一起执行一个任务的语句。
您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。
函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。
## 函数定义
函数就是包裹在花括号中的代码块，前面使用了关键词 function：
语法格式如下所示：
```
function function_name(){// 执行代码}
```

### 实例
## TypeScript
function(){// 函数定义console.log("调用函数")}
## 调用函数
函数只有通过调用才可以执行函数内的代码。
语法格式如下所示：
```
function_name()
```

### 实例
## TypeScript
functiontest(){// 函数定义console.log("调用函数")}test()// 调用函数
## 函数返回值
有时，我们会希望函数将执行的结果返回到调用它的地方。
通过使用 return 语句就可以实现。
在使用 return 语句时，函数会停止执行，并返回指定的值。
语法格式如下所示：
```
function function_name():return_type {// 语句return value;}
```

  * return_type 是返回值的类型。
  * return 关键词后跟着要返回的结果。
  * 一般情况下，一个函数只有一个 return 语句。
  * 返回值的类型需要与函数定义的返回类型(return_type)一致。


### 实例
## TypeScript
// 函数定义functiongreet():string{// 返回一个字符串return"Hello World"}functioncaller(){varmsggreet()// 调用 greet() 函数 console.log(msg)}// 调用函数caller()
  * 实例中定义了函数 _greet()_ ，返回值的类型为 string。
  * _greet()_ 函数通过 return 语句返回给调用它的地方，即变量 msg，之后输出该返回值。。


编译以上代码，得到以下 JavaScript 代码：
## JavaScript
// 函数定义functiongreet(){return"Hello World"}functioncaller(){varmsggreet()// 调用 greet() 函数 console.log(msg)}// 调用函数caller();
## 带参数函数
在调用函数时，您可以向其传递值，这些值被称为参数。
这些参数可以在函数中使用。
您可以向函数发送多个参数，每个参数使用逗号 , 分隔：
语法格式如下所示：
```
function func_name( param1 [:datatype], param2 [:datatype]){}
```

  * param1、param2 为参数名。
  * datatype 为参数类型。


### 实例
## TypeScript
functionadd(xnumberynumber)number{returnxy}console.log(add(1,2))
  * 实例中定义了函数 _add()_ ，返回值的类型为 number。
  * _add()_ 函数中定义了两个 number 类型的参数，函数内将两个参数相加并返回。


编译以上代码，得到以下 JavaScript 代码：
## JavaScript
functionadd(xy){returnxy}console.log(add(12));
输出结果为：
## 可选参数和默认参数
### 可选参数
在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。
## TypeScript
functionbuildName(firstNamestringlastNamestring){returnfirstName""lastName}letresult1buildName("Bob")// 错误，缺少参数letresult2buildName("Bob""Adams""Sr.")// 错误，参数太多了letresult3buildName("Bob""Adams")// 正确
以下实例，我们将 lastName 设置为可选参数：
## TypeScript
functionbuildName(firstNamestringlastName?: string){if(lastName)returnfirstName""lastNameelsereturnfirstName}letresult1buildName("Bob")// 正确letresult2buildName("Bob""Adams""Sr.")// 错误，参数太多了letresult3buildName("Bob""Adams")// 正确
可选参数必须跟在必需参数后面。 如果上例我们想让 firstName 是可选的，lastName 必选，那么就要调整它们的位置，把 firstName 放在后面。
如果都是可选参数就没关系。
###  默认参数 
我们也可以设置参数的默认值，这样在调用函数的时候，如果不传入该参数的值，则使用默认参数，语法格式为：
```
function function_name(param1[:type],param2[:type]= default_value){}
```

注意：参数不能同时设置为可选和默认。
以下实例函数的参数 rate 设置了默认值为 0.50，调用该函数时如果未传入参数则使用该默认值：
## TypeScript
functioncalculate_discount(price:number,rate:number0.50){vardiscountpricerateconsole.log("计算结果: ",discount)}calculate_discount(1000)calculate_discount(1000,0.30)
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
functioncalculate_discount(pricerate){if(rate === void0){rate0.50}vardiscountpricerateconsole.log("计算结果: "discount)}calculate_discount(1000)calculate_discount(10000.30);
输出结果为：
```
计算结果:500计算结果:300
```

##  剩余参数 
有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。
剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入。
## TypeScript
functionbuildName(firstNamestring, ...restOfNamestring[]){returnfirstName""restOfName.join("")}letemployeeNamebuildName("Joseph""Samuel""Lucas""MacKinzie");
函数的最后一个命名参数 restOfName 以 ... 为前缀，它将成为一个由剩余参数组成的数组，索引值从0（包括）到 restOfName.length（不包括）。
## TypeScript
functionaddNumbers(...nums:number[]){varivarsum:number0for(i0;inums.length;i++){sumsumnums[i]}console.log("和为：",sum)}addNumbers(1,2,3)addNumbers(10,10,10,10,10)
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
functionaddNumbers(){varnums[]for(var_i0_iarguments.length_i++){nums[_i]arguments[_i]}varivarsum0for(i0inums.lengthi++){sumsumnums[i]}console.log("和为："sum)}addNumbers(123)addNumbers(1010101010);
输出结果为：
## 匿名函数
匿名函数是一个没有函数名的函数。
匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。
我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。
语法格式如下：
```
var res =function([arguments]){...}
```

### 实例
不带参数匿名函数：
## TypeScript
varmsgfunction(){return"hello world"}console.log(msg())
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
varmsgfunction(){return"hello world"}console.log(msg());
输出结果为：
```
hello world
```

带参数匿名函数：
## TypeScript
varresfunction(a:number,b:number){returna*b}console.log(res(12,2))
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
varresfunction(ab){returnab}console.log(res(122));
输出结果为：
### 匿名函数自调用
匿名函数自调用在函数后使用 () 即可： 
## TypeScript
(function(){varx"Hello!!"console.log(x)})()
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
(function(){varx"Hello!!"console.log(x)})()
输出结果为：
## 构造函数
TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：
语法格式如下：
```
var res =newFunction([arg1[, arg2[,...argN]],] functionBody)
```

参数说明：
  * **arg1, arg2, ... argN** ：参数列表。 
  * **functionBody** ：一个含有包括函数定义的 JavaScript 语句的字符串。 


### 实例
## TypeScript
varmyFunctionnewFunction("a""b""return a * b")varxmyFunction(43)console.log(x);
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
varmyFunctionnewFunction("a""b""return a * b")varxmyFunction(43)console.log(x);
输出结果为：
## 递归函数
递归函数即在函数内调用函数本身。 
> 举个例子： 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？"从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？'从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……'" 
### 实例
## TypeScript
functionfactorial(number){if(number0){// 停止执行return1}else{return(numberfactorial(number1))// 调用自身}}console.log(factorial(6))// 输出 720
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
functionfactorial(number){if(number0){// 停止执行return1}else{return(numberfactorial(number1))// 调用自身}}console.log(factorial(6))// 输出 720
输出结果为：
## Lambda 函数
Lambda 函数也称之为箭头函数。
箭头函数表达式的语法比函数表达式更短。
函数只有一行语句：
```
([param1, param2,…param n]statement;
```

### 实例
以下实例声明了 lambda 表达式函数，函数返回两个数的和： 
## TypeScript
varfoo(x:number)10xconsole.log(foo(100))//输出结果为 110
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
varfoofunction(x){return10x}console.log(foo(100))//输出结果为 110
输出结果为：
函数是一个语句块：
```
([param1, param2,…param n]{// 代码块}
```

### 实例
以下实例声明了 lambda 表达式函数，函数返回两个数的和：
## TypeScript
varfoo(x:number){x10xconsole.log(x)}foo(100)
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
varfoofunction(x){x10xconsole.log(x)}foo(100);
输出结果为：
我们可以不指定函数的参数类型，通过函数内来推断参数类型: 
## TypeScript
varfunc(x){if(typeofx=="number"){console.log(x+" 是一个数字")}elseif(typeofx=="string"){console.log(x+" 是一个字符串")}}func(12)func("Tom")
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
varfuncfunction(x){if(typeofx"number"){console.log(x" 是一个数字")}elseif(typeofx"string"){console.log(x" 是一个字符串")}}func(12)func("Tom");
输出结果为：
```
12是一个数字Tom是一个字符串
```

单个参数 () 是可选的：
## TypeScript
vardisplayx{console.log("输出为 "+x)}display(12)
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
vardisplayfunction(x){console.log("输出为 "x)}display(12);
输出结果为：
无参数时可以设置空括号：
## TypeScript
vardisp(){console.log("Function invoked")}disp();
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
vardispfunction(){console.log("调用函数")}disp();
输出结果为：
## 函数重载
重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
参数类型不同：
```
function disp(string):void;function disp(number):void;
```

参数数量不同：
```
function disp(n1:number):void;function disp(x:number,y:number):void;
```

参数类型顺序不同：
```
function disp(n1:number,s1:string):void;function disp(s:string,n:number):void;
```

如果参数类型不同，则参数类型应设置为 **any** 。 
参数数量不同你可以将不同的参数设置为可选。
### 实例
以下实例定义了参数类型与参数数量不同：
## TypeScript
functiondisp(s1:string):voidfunctiondisp(n1:number,s1:string):voidfunctiondisp(x:any,y?:any):void{console.log(x)console.log(y)}disp("abc")disp(1,"xyz");
编译以上代码，得到以下 JavaScript 代码：
## JavaScript
functiondisp(xy){console.log(x)console.log(y)}disp("abc")disp(1"xyz");
输出结果为：
```
abc
undefined1
xyz
```

  1. #0
定义函数重载需要定义**重载签名** 和一个**实现签名** 。
重载签名定义函数的形参和返回类型，没有函数体。一个函数可以**有多个** 重载签名(不可调用)
```
let suits =["hearts","spades","clubs","diamonds"];// 定义重载签名function greet(person:string):string;function greet(persons:string[]):string[];// 定义实现签名function greet(person: unknown): unknown {if(typeof person ==='string'){return`Hello, ${person}!`;}elseif(Array.isArray(person)){return person.map(name `Hello, ${name}!`);}thrownewError('Unable to greet');}
console.log(greet(suits[0]));
console.log(greet(suits));
```

js 编译后实际代码：
```
var suits =["hearts","spades","clubs","diamonds"];// 实现签名function greet(person){if(typeof person ==='string'){return"Hello, ".concat(person,"!");}elseif(Array.isArray(person)){return person.map(function(name){return"Hello, ".concat(name,"!");});}thrownewError('Unable to greet');}
console.log(greet(suits[0]));
console.log(greet(suits));
```

4年前 (2021-12-29)


  * HTML / CSS
  * JavaScript
  * 服务端
  * 数据库
  * AI & 数据分析
  * 移动端
  * 开发工具
  * XML 教程
  * ASP.NET
  * Web Service
  * 网站建设


